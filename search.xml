<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1010. 总持续时间可被 60 整除的歌曲</title>
    <url>/2023/05/07/Leetcode-1010/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。</p>
<p>返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望下标数字 i 和 j 满足  i &lt; j 且有 (time[i] + time[j]) % 60 == 0。</p>
<p>示例1:</p>
<p><strong>输入</strong>：time = [30,20,150,100,40]</p>
<p><strong>输出</strong>：3</p>
<p><strong>解释</strong>：这三对的总持续时间可被 60 整除：</p>
<p>(time[0] = 30, time[2] = 150): 总持续时间 180</p>
<p>(time[1] = 20, time[3] = 100): 总持续时间 120</p>
<p>(time[1] = 20, time[4] = 40): 总持续时间 60</p>
<p>示例2:</p>
<p><strong>输入</strong>：time = [60,60,60]</p>
<p><strong>输出</strong>：3</p>
<p><strong>解释</strong>：所有三对的总持续时间都是 120，可以被 60 整除。</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一个想法就是一个二重循环遍历各个歌曲对之间能不能符合题目条件，时间复杂度O($n^2$)，会超时。</p>
<p>对于有两个变量的题目，通常可以枚举其中一个变量，把它视作常量，从而转化成只有一个变量的问题。</p>
<p>需要返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量，因此，每首歌曲对结果的影响因素是它的持续时间除以 60 后的余数。可以用一个长度为 60 的数组 cnt，用来表示余数出现的次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numPairsDivisibleBy60</span>(<span class="params">self, time: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">60</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> time:</span><br><span class="line">            cnt[num % <span class="number">60</span>] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">30</span>):</span><br><span class="line">            ans = ans + cnt[i] * cnt[<span class="number">60</span>-i]</span><br><span class="line">        </span><br><span class="line">        ans = ans + (cnt[<span class="number">0</span>] * (cnt[<span class="number">0</span>] - <span class="number">1</span>)) // <span class="number">2</span> + (cnt[<span class="number">30</span>] * (cnt[<span class="number">30</span>] - <span class="number">1</span>)) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>1263. 推箱子</title>
    <url>/2023/05/09/Leetcode-1263/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。</p>
<p>游戏地图用大小为 m x n 的网格 grid 表示，其中每个元素可以是墙、地板或者是箱子。</p>
<p>现在你将作为玩家参与游戏，按规则将箱子 ‘B’ 移动到目标位置 ‘T’ ：</p>
<ul>
<li>玩家用字符 ‘S’ 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。</li>
<li>地板用字符 ‘.’ 表示，意味着可以自由行走。</li>
<li>墙用字符 ‘#’ 表示，意味着障碍物，不能通行。</li>
<li>箱子仅有一个，用字符 ‘B’ 表示。相应地，网格上有一个目标位置 ‘T’。</li>
<li>玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。</li>
<li>玩家无法越过箱子。</li>
</ul>
<p>返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回 -1。</p>
<p><img src="https://github.com/wuli-tao/wuli-tao.github.io/blob/master/image/1263.png?raw=true" alt="Image"></p>
<p>示例1：</p>
<p><strong>输入</strong>：grid = [[“#”,”#”,”#”,”#”,”#”,”#”],<br>             [“#”,”T”,”#”,”#”,”#”,”#”],<br>             [“#”,”.”,”.”,”B”,”.”,”#”],<br>             [“#”,”.”,”#”,”#”,”.”,”#”],<br>             [“#”,”.”,”.”,”.”,”S”,”#”],<br>             [“#”,”#”,”#”,”#”,”#”,”#”]】</p>
<p><strong>输出</strong>：3</p>
<p><strong>解释</strong>：我们只需要返回推箱子的次数</p>
<p>示例2：</p>
<p><strong>输入</strong>：grid = [[“#”,”#”,”#”,”#”,”#”,”#”],<br>             [“#”,”T”,”#”,”#”,”#”,”#”],<br>             [“#”,”.”,”.”,”B”,”.”,”#”],<br>             [“#”,”#”,”#”,”#”,”.”,”#”],<br>             [“#”,”.”,”.”,”.”,”S”,”#”],<br>             [“#”,”#”,”#”,”#”,”#”,”#”]]</p>
<p><strong>输出</strong>：-1</p>
<p>示例3:</p>
<p><strong>输入</strong>：grid = [[“#”,”#”,”#”,”#”,”#”,”#”],<br>             [“#”,”T”,”.”,”.”,”#”,”#”],<br>             [“#”,”.”,”#”,”B”,”.”,”#”],<br>             [“#”,”.”,”.”,”.”,”.”,”#”],<br>             [“#”,”.”,”.”,”.”,”S”,”#”],<br>             [“#”,”#”,”#”,”#”,”#”,”#”]]</p>
<p><strong>输出</strong>：5</p>
<p><strong>解释</strong>：向下、向左、向左、向上再向上。</p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>搜索问题可以转化成图的问题。将每一步操作作为图中的一个节点，推动箱子表示1，否则表示0。</p>
<p>记地图行为 m ，列为 n ，将坐标(x, y)按照一维数组方式x $\times$ n + y 进行编码。首先遍历整个地图grid得到人和箱子所在地。使用dp来记录在某个状态下最小的推动次数，初始值为0。利用q队列来暂存当前推动箱子次数下所有可能的情况，q_next来暂存下一个推动箱子次数的可能情况。</p>
<p>不断的从q中取出状态，如果箱子的位置等于目标位置，则返回当时状态的最小推动次数，否则就要进行下一个状态的转移，即</p>
<ol>
<li>如果移动后位置不合法，执行q中下一个状态</li>
<li>根据玩家移动后的位置和箱子的位置，分为两种情况<ul>
<li>玩家移动后和箱子位置一致：则将箱子往人移动的方向进行移动。若不合法或者该状态已经被访问过，就执行下一个状态，否则将移动后的状态记录到q_next中，此时最小移动次数要+1。</li>
<li>玩家移动后和箱子位置不一致：如果状态被访问，执行下一个状态，否则将该状态记录到q中，此时最小移动次数不变。<br>当q为空时，若q_next非空，则交换两队列，否则说明无解，返回-1.<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPushBox</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        sx, sy, bx, by = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 找到人和箱子的坐标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                    sx = i</span><br><span class="line">                    sy = j</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">                    bx = i</span><br><span class="line">                    by = j</span><br><span class="line">        <span class="comment"># 判断位置是否合法</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x, y</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> &lt;= x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; n <span class="keyword">and</span> grid[x][y] != <span class="string">&#x27;#&#x27;</span></span><br><span class="line"></span><br><span class="line">        way = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]  <span class="comment"># 方向数组，表示移动的方向</span></span><br><span class="line">        dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (m * n) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m * n)]   <span class="comment"># 行表示人，列表示箱子，记录当前人和箱子所在位置推动的最小值</span></span><br><span class="line">        dp[sx * n + sy][bx * n + by] = <span class="number">0</span></span><br><span class="line">        q = [(sx * n + sy, bx * n + by)]    <span class="comment"># 当前推动次数下所有可能的状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            q_next = [] <span class="comment"># 下一个推动次数可能的状态</span></span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                s1, b1 = q.pop(<span class="number">0</span>)</span><br><span class="line">                sx1, sy1 = s1 // n, s1 % n</span><br><span class="line">                bx1, by1 = b1 // n, b1 % n</span><br><span class="line">                <span class="comment"># 若箱子位置为最终位置，返回最小推动次数</span></span><br><span class="line">                <span class="keyword">if</span> grid[bx1][by1] == <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> dp[s1][b1]</span><br><span class="line">                <span class="comment"># 对四个方向进行一次遍历</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                    sx2, sy2 = sx1 + way[i], sy1 + way[i + <span class="number">1</span>]</span><br><span class="line">                    s2 = sx2 * n + sy2</span><br><span class="line">                    <span class="comment"># 非法则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> check(sx2, sy2):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 若人和箱子位置一致，要将箱子向移动方向移动一格</span></span><br><span class="line">                    <span class="keyword">if</span> sx2 == bx1 <span class="keyword">and</span> sy2 == by1:</span><br><span class="line">                        bx2, by2 = bx1 + way[i], by1 + way[i + <span class="number">1</span>]</span><br><span class="line">                        b2 = bx2 * n + by2</span><br><span class="line">                        <span class="comment"># 若不合法或者访问过，则跳过</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> check(bx2, by2) <span class="keyword">or</span> dp[s2][b2] &lt;= dp[s1][b1]:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="comment"># 若合法，则加入下一个推动次数的队列</span></span><br><span class="line">                        dp[s2][b2] = dp[s1][b1] + <span class="number">1</span></span><br><span class="line">                        q_next.append((s2, b2))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> dp[s2][b1] &lt;= dp[s1][b1]:    <span class="comment"># 若不一致，并且访问过</span></span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        dp[s2][b1] = dp[s1][b1]</span><br><span class="line">                        q.append((s2, b1))  <span class="comment"># 不一致但是未访问过</span></span><br><span class="line">            <span class="comment"># 若q为空，表示当前步数所有情况都遍历完成，交换q和q_next</span></span><br><span class="line">            q, q_next = q_next, q</span><br><span class="line">        <span class="comment"># 若q未空，表示无解，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>C++语法</title>
    <url>/2023/04/01/C++%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95%20/</url>
    <content><![CDATA[<h2 id="数字与字符串转换"><a href="#数字与字符串转换" class="headerlink" title="数字与字符串转换"></a>数字与字符串转换</h2>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数字转字符串</span></span><br><span class="line">std::string str = std::<span class="built_in">to_string</span>(num)	<span class="comment">// num为数字</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 字符串转数字</span></span><br><span class="line"><span class="type">int</span> i = std::<span class="built_in">stoi</span>(str);	<span class="comment">// str为字符串</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="截取子串"><a href="#截取子串" class="headerlink" title="截取子串"></a>截取子串</h2>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string str;</span><br><span class="line">str.<span class="built_in">substr</span> (pos, n);	<span class="comment">// 截取 str 中从 pos 开始（包括 0）的 n 个字符的子串，并返回</span></span><br><span class="line">str.<span class="built_in">substr</span> (pos);	<span class="comment">// 截取 s 中从从 pos 开始（包括 0）到末尾的所有字符的子串，并返回</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>1419. 数青蛙</title>
    <url>/2023/05/06/Leetcode-1419/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 “croak”）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 croakOfFrogs 中会混合多个 “croak”。</p>
<p>请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p>
<p>要想发出蛙鸣 “croak”，青蛙必须依序输出 ‘c’, ’r’, ’o’, ’a’, ’k’ 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。如果字符串 croakOfFrogs 不是由若干有效的 “croak” 字符混合而成，请返回 -1。</p>
<p>示例1:</p>
<p><strong>输入</strong>：croakOfFrogs = “croakcroak”</p>
<p><strong>输出</strong>：1</p>
<p><strong>解释</strong>：一只青蛙 “呱呱” 两次</p>
<p>示例2:<br><strong>输入</strong>：croakOfFrogs = “crcoakroak”</p>
<p><strong>输出</strong>：2</p>
<p><strong>解释</strong>：最少需要两只青蛙，“呱呱” 声用黑体标注</p>
<p>第一只青蛙 “<strong>cr</strong>c<strong>oak</strong>roak”</p>
<p>第二只青蛙 “cr<strong>c</strong>oak<strong>roak</strong>“</p>
<p>示例3:</p>
<p><strong>输入</strong>：croakOfFrogs = “croakcrook”</p>
<p><strong>输出</strong>：-1</p>
<p><strong>解释</strong>：给出的字符串不是 “croak” 的有效组合。</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用一位数组sound来记录各个字母出现的次数，遍历croakOfFrogs，如果是’c’意味着是新开头，x变量加一，否则对应变量前一个字符出现次数减一。如果该字符为’k’表示一次完整的蛙鸣，则x减一。</p>
<p>最后要判断x的值，若非空则有不完整的蛙鸣，返回-1，否则返回最大值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minNumberOfFrogs</span>(<span class="params">self, croakOfFrogs: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        hashmap = &#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;o&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;k&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line">        sound = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        ans = x = <span class="number">0</span>    <span class="comment"># x表示未完成的蛙鸣的青蛙的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(croakOfFrogs)):</span><br><span class="line">            sound[hashmap[croakOfFrogs[i]]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> croakOfFrogs[i] == <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, x)   <span class="comment"># 要求最大次数，出现多少个&#x27;c&#x27;就代表有多少蛙鸣，ans也就要是x和ans中的最大值。</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> sound[hashmap[croakOfFrogs[i]]-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                sound[hashmap[croakOfFrogs[i]] - <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> croakOfFrogs[i] == <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">                     x -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>1743. 从相邻元素对还原数组</title>
    <url>/2023/05/02/Leetcode-1743/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>存在一个由 n 个不同元素组成的整数数组nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。</p>
<p>给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [u<sub>i</sub>, v<sub>i</sub>] 表示元素 u<sub>i</sub> 和 v<sub>i</sub> 在 nums 中相邻。</p>
<p>题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。</p>
<p>返回原始数组 nums 。如果存在多种解答，返回其中任意一个即可。</p>
<p>示例1:</p>
<p><strong>输入</strong>：adjacentPairs = [[2,1],[3,4],[3,2]]</p>
<p><strong>输出</strong>：[1,2,3,4]</p>
<p><strong>解释</strong>：数组的所有相邻元素对都在 adjacentPairs 中。<br>特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。</p>
<p>示例2:</p>
<p><strong>输入</strong>：adjacentPairs = [[4,-2],[1,4],[-3,1]]</p>
<p><strong>输出</strong>：[-2,4,1,-3]</p>
<p><strong>解释</strong>：数组中可能存在负数。<br>另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。</p>
<p>示例3:</p>
<p><strong>输入</strong>：adjacentPairs = [[100000,-100000]]</p>
<p><strong>输出</strong>：[100000,-100000]</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>在该问题中，开头和结尾的数组只会出现一次，所以建立哈希表，将开头的数字找出来，再利用开头一次寻找下一个相邻数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">restoreArray</span>(<span class="params">self, adjacentPairs: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(adjacentPairs) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> adjacentPairs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        hashmap = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> adjacentPairs:</span><br><span class="line">            hashmap[pair[<span class="number">0</span>]].append(pair[<span class="number">1</span>])</span><br><span class="line">            hashmap[pair[<span class="number">1</span>]].append(pair[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 找到开头</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> hashmap.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(value) == <span class="number">1</span>:</span><br><span class="line">                ans.append(key)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 利用开头找到后续相邻数字</span></span><br><span class="line">        ans.append(hashmap[ans[<span class="number">0</span>]][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">len</span>(ans) != <span class="built_in">len</span>(adjacentPairs)+<span class="number">1</span>):</span><br><span class="line">            temp = hashmap[ans[-<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">if</span> temp[<span class="number">0</span>] == ans[-<span class="number">2</span>]:</span><br><span class="line">                ans.append(temp[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(temp[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>2141. 同时运行 N 台电脑的最长时间</title>
    <url>/2023/05/05/Leetcode-2141/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries ，其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟。你想使用这些电池让全部 n 台电脑同时运行。</p>
<p>一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作任意次。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p>
<p>注意，你不能给电池充电。</p>
<p>请你返回你可以让 n 台电脑同时运行的最长分钟数。</p>
<p>示例1:</p>
<p><img src="https://github.com/wuli-tao/wuli-tao.github.io/blob/master/image/2141_1.png?raw=true" alt="image1"></p>
<p><strong>输入</strong>：n = 2, batteries = [3,3,3]</p>
<p><strong>输出</strong>：4</p>
<p><strong>解释</strong>：</p>
<p>一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 1 连接。</p>
<p>2 分钟后，将第二台电脑与电池 1 断开连接，并连接电池 2。注意，电池 0 还可以供电 1 分钟。</p>
<p>在第 3 分钟结尾，你需要将第一台电脑与电池 0 断开连接，然后连接电池 1。</p>
<p>在第 4 分钟结尾，电池 1 也被耗尽，第一台电脑无法继续运行。</p>
<p>我们最多能同时让两台电脑同时运行 4 分钟，所以我们返回 4。</p>
<p>示例2:</p>
<p><img src="https://github.com/wuli-tao/wuli-tao.github.io/blob/master/image/2141_2.png?raw=true" alt="image2"></p>
<p><strong>输入</strong>：n = 2, batteries = [1,1,1,1]</p>
<p><strong>输出</strong>：2</p>
<p><strong>解释</strong>：</p>
<p>一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 2 连接。</p>
<p>一分钟后，电池 0 和电池 2 同时耗尽，所以你需要将它们断开连接，并将电池 1 和第一台电脑连接，电池 3 和第二台电脑连接。</p>
<p>1 分钟后，电池 1 和电池 3 也耗尽了，所以两台电脑都无法继续运行。</p>
<p>我们最多能让两台电脑同时运行 2 分钟，所以我们返回 2。</p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题可以转化为二分查找问题。</p>
<p>假设我们可以让 n 台电脑同时运行 x 分钟，那么对于电量大于 x 的电池，其只能被使用 x 分钟。因此每个电池的使用时间至多为 min⁡(batteries[i],x)，我们将其累加起来，记作 sum。那么要让 n 台电脑同时运行 x 分钟，必要条件是 n⋅x≤sum。</p>
<p>下面证明该条件是充分的，即当 n⋅x≤sum 成立时，必然可以让 n 台电脑同时运行 x 分钟。</p>
<p>对于电量不小于 x 的电池，我们可以让其给一台电脑供电 x 分钟。由于一个电池不能同时给多台电脑供电，因此该电池若给一台电脑供电 xxx 分钟，那它就不能用于其他电脑了（因为电脑运行时间就是 x 分钟）。我们可以将所有电量不小于 x 的电池各给一台电脑供电。</p>
<p>对于其余的电池，设其电量和为 sum’，剩余 n’ 台电脑未被供电。我们可以随意选择剩下的电池，供给剩余的第一台电脑（用完一个电池就换下一个电池），多余的电池电量与剩下的电池一起供给剩余的第二台电脑，依此类推。注意由于这些电池的电量均小于 x，按照这种做法是不会出现同一个电池在同一时间供给多台电脑的（如果某个电池供给了两台电脑，可以将这个电池的供电时间划分到第一台电脑的末尾和第二台电脑的开头）。</p>
<p>由于 sum’=sum−(n−n’)⋅x，结合 n⋅x≤sum 可以得到 n⋅x≤sum ，按照上述供电方案（用完一个电池就换下一个电池），这 n’ 台电脑可以运行至少 x 分钟。充分性得证。</p>
<p>如果我们可以让 n 台电脑同时运行 x 分钟，那么必然也可以同时运行低于 x 分钟，因此答案满足单调性，可以二分答案，通过判断 n⋅x≤sum 来求解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxRunTime</span>(<span class="params">self, n: <span class="built_in">int</span>, batteries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">sum</span>(batteries) // n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l + r + <span class="number">1</span>) // <span class="number">2</span>    <span class="comment"># 此处要+1，不然会导致m=l&lt;r，从而导致死循环</span></span><br><span class="line">            <span class="keyword">if</span> n * m &lt;= <span class="built_in">sum</span>(<span class="built_in">min</span>(b, m) <span class="keyword">for</span> b <span class="keyword">in</span> batteries):  <span class="comment"># 此处要判断等于，所以下面的操作是l=m，而不是m+1</span></span><br><span class="line">                l = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>2106. 摘水果</title>
    <url>/2023/05/04/Leetcode-2106/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 fruits ，其中 fruits[i] = [position<sub>i</sub>, amount<sub>i</sub>,] 表示共有 amount<sub>i</sub>, 个水果放置在 position<sub>i</sub>, 上。fruits 已经按 position<sub>i</sub>, 升序排列 ，每个 position<sub>i</sub>, 互不相同。</p>
<p>另给你两个整数 startPos 和 k 。最初，你位于 startPos 。从任何位置，你可以选择向左或者向右走。在 x 轴上每移动 一个单位 ，就记作一步 。你总共可以走最多 k 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。</p>
<p>返回你可以摘到水果的最大总数。</p>
<p>示例1:</p>
<p><img src="https://github.com/wuli-tao/wuli-tao.github.io/blob/master/image/2106_1.png?raw=true" alt="image1"></p>
<p><strong>输入</strong>：fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4</p>
<p><strong>输出</strong>：9</p>
<p><strong>解释</strong>：最佳路线为：</p>
<ul>
<li>向右移动到位置 6 ，摘到 3 个水果</li>
<li>向右移动到位置 8 ，摘到 6 个水果</li>
</ul>
<p>移动 3 步，共摘到 3 + 6 = 9 个水果</p>
<p>示例2:</p>
<p><img src="https://github.com/wuli-tao/wuli-tao.github.io/blob/master/image/2106_2.png?raw=true" alt="image2"></p>
<p><strong>输入</strong>：fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4</p>
<p><strong>输出</strong>：14</p>
<p><strong>解释</strong>：可以移动最多 k = 4 步，所以无法到达位置 0 和位置 10 。</p>
<p>最佳路线为：</p>
<ul>
<li>在初始位置 5 ，摘到 7 个水果</li>
<li>向左移动到位置 4 ，摘到 1 个水果</li>
<li>向右移动到位置 6 ，摘到 2 个水果</li>
<li>向右移动到位置 7 ，摘到 4 个水果</li>
</ul>
<p>移动 1 + 3 = 4 步，共摘到 7 + 1 + 2 + 4 = 14 个水果</p>
<p>示例3:</p>
<p><img src="https://github.com/wuli-tao/wuli-tao.github.io/blob/master/image/2106_3.png?raw=true" alt="image3"></p>
<p><strong>输入</strong>：fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2</p>
<p><strong>输出</strong>：0</p>
<p><strong>解释</strong>：最多可以移动 k = 2 步，无法到达任一有水果的地方</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目的关键是求从起点移动 k 步而实际在 x 轴上移动的最大区间范围，求出范围内的水果数量即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTotalFruits</span>(<span class="params">self, fruits: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], startPos: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(fruits)</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">step</span>(<span class="params">left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> fruits[right][<span class="number">0</span>] &lt;= startPos:</span><br><span class="line">                <span class="keyword">return</span> startPos - fruits[left][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> fruits[left][<span class="number">0</span>] &gt;= startPos:</span><br><span class="line">                <span class="keyword">return</span> fruits[right][<span class="number">0</span>] - startPos</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">abs</span>(startPos - fruits[right][<span class="number">0</span>]), <span class="built_in">abs</span>(startPos - fruits[left][<span class="number">0</span>])) + \</span><br><span class="line">                    fruits[right][<span class="number">0</span>] - fruits[left][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每次固定住窗口右边界</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            <span class="built_in">sum</span> += fruits[right][<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 移动左边界</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> step(left, right) &gt; k:</span><br><span class="line">                <span class="built_in">sum</span> -= fruits[left][<span class="number">1</span>]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">sum</span>)</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>45. 跳跃游戏 II</title>
    <url>/2023/05/04/Leetcode-45/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p>
<p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p>
<ul>
<li>0 &lt;= j &lt;= nums[i]</li>
<li>i + j &lt; n</li>
</ul>
<p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p>
<p>示例1:</p>
<p><strong>输入</strong>: nums = [2,3,1,1,4]</p>
<p><strong>输出</strong>: 2</p>
<p><strong>解释</strong>:</p>
<p>跳到最后一个位置的最小跳跃数是 2。</p>
<p>从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
<p>示例2:</p>
<p><strong>输入</strong>: nums = [2,3,0,1,4]</p>
<p><strong>输出</strong>: 2</p>
<span id="more"></span>

<h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        step = nums[<span class="number">0</span>]</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pos != <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">max</span> = <span class="number">0</span></span><br><span class="line">            max_idx = pos</span><br><span class="line">            <span class="keyword">if</span> pos + step &gt;= <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">                time += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos+<span class="number">1</span>, pos+step+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> i+nums[i] &gt;= <span class="built_in">max</span>:    <span class="comment"># 此处贪心算法要求跳到i的下一步也要是最远的，所以应该是i+nums[i]而不是nums[i]</span></span><br><span class="line">                        max_idx = i</span><br><span class="line">                        <span class="built_in">max</span> = nums[i]+i</span><br><span class="line">            </span><br><span class="line">            time += <span class="number">1</span></span><br><span class="line">            pos = max_idx</span><br><span class="line">            step = nums[pos]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> time</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>1315. 祖父节点值为偶数的节点和</title>
    <url>/2023/05/01/Leetcode-1315/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一颗二叉树，请你返回满足以下条件的所有节点的值之和：</p>
<ul>
<li>该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）如果不存在祖父节点值为偶数的节点，那么返回 0 。</li>
</ul>
<p><strong>输入</strong>：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]</p>
<p><strong>输出</strong>：18</p>
<p><strong>解释</strong>：图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。</p>
<p><img src="https://github.com/wuli-tao/wuli-tao.github.io/blob/master/image/1315.png?raw=true" alt="image"></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于有父节点和祖父节点的问题，可以考虑三元组。（祖父节点，父节点，本身节点），并且利用dfs进行递归搜索。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumEvenGrandparent</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">gp_val, f_val, node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> gp_val % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">nonlocal</span> ans</span><br><span class="line">                ans += node.val</span><br><span class="line">            </span><br><span class="line">            dfs(f_val, node.val, node.left)</span><br><span class="line">            dfs(f_val, node.val, node.right)</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>, root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>python语法</title>
    <url>/2023/04/01/Python%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="str（字符串）"><a href="#str（字符串）" class="headerlink" title="str（字符串）"></a>str（字符串）</h2>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 子串sub在str中出现的次数</span></span><br><span class="line"><span class="built_in">str</span>.count(sub[,start[,end]])</span><br><span class="line"><span class="built_in">str</span>：表示原字符串；</span><br><span class="line">sub：表示要检索的字符串；</span><br><span class="line">start：指定检索的起始位置，也就是从什么位置开始检测。如果不指定，默认从头开始检索；</span><br><span class="line">end：指定检索的终止位置，如果不指定，则表示一直检索到结尾。</span><br><span class="line"></span><br><span class="line"><span class="comment"># str -&gt; list</span></span><br><span class="line">str1 = <span class="string">&quot;12345&quot;</span></span><br><span class="line">list1 = <span class="built_in">list</span>(str1)	<span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br><span class="line">str2 = <span class="string">&quot;123 sjhid  dhi&quot;</span></span><br><span class="line">list2 = str2.split()	<span class="comment"># [&#x27;123&#x27;, &#x27;sjhid&#x27;, &#x27;&#x27;, &#x27;dhi&#x27;]</span></span><br><span class="line">str3 = <span class="string">&quot;www.google.com&quot;</span></span><br><span class="line">list3 = str3.split(<span class="string">&quot;.&quot;</span>)	<span class="comment"># [&#x27;www&#x27;, &#x27;google&#x27;, &#x27;com&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字母大小写转换</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.upper())          <span class="comment"># 把所有字符中的小写字母转换成大写字母，WWW.RUNOOB.COM</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.lower())          <span class="comment"># 把所有字符中的大写字母转换成小写字母，www.runoob.com</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.capitalize())     <span class="comment"># 把第一个字母转化为大写字母，其余小写，Www.runoob.com</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.title())          <span class="comment"># 把每个单词的第一个字母转化为大写，其余小写，Www.Runoob.Com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sorted()，会把str转成list</span></span><br><span class="line">s = <span class="string">&#x27;cba&#x27;</span></span><br><span class="line"><span class="built_in">sorted</span>(s)	<span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h2 id="list（列表）"><a href="#list（列表）" class="headerlink" title="list（列表）"></a>list（列表）</h2>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个临时(二维)List</span></span><br><span class="line"><span class="type">List</span> = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(column)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row)]	<span class="comment"># column为列数,row为行数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除数组中的某个元素</span></span><br><span class="line"><span class="type">List</span> = [a, b, c]</span><br><span class="line"><span class="type">List</span>.remove(<span class="string">&#x27;a&#x27;</span>)	<span class="comment"># 移除元素a，参数表示要移除的元素</span></span><br><span class="line"><span class="type">List</span> = [a, b, c]</span><br><span class="line"><span class="type">List</span>.pop(<span class="number">1</span>)			<span class="comment"># 移除元素a，并返回这个a，参数表示index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找x在list中第一次出现的index</span></span><br><span class="line"><span class="built_in">list</span>.index(x[, start[, end]])</span><br><span class="line">x-- 查找的对象。</span><br><span class="line">start-- 可选，查找的起始位置。</span><br><span class="line">end-- 可选，查找的结束位置。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组取列</span></span><br><span class="line">a=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">a[:, <span class="number">0</span>]                   <span class="comment"># 尝试用数组的方法读取一列失败</span></span><br><span class="line">TypeError: <span class="built_in">list</span> indices must be integers <span class="keyword">or</span> slices, <span class="keyword">not</span> <span class="built_in">tuple</span></span><br><span class="line"></span><br><span class="line">b = [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> a]     <span class="comment"># 从a中的每一行取第一个元素。</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给list排序</span></span><br><span class="line"><span class="built_in">list</span> = [[-<span class="number">6</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">6</span>], [<span class="number">8</span>, <span class="number">10</span>], [-<span class="number">1</span>, <span class="number">4</span>], [-<span class="number">6</span>, -<span class="number">2</span>], [-<span class="number">9</span>, <span class="number">8</span>], [-<span class="number">5</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">3</span>]]</span><br><span class="line">list_new = <span class="built_in">sorted</span>(<span class="built_in">list</span>, key=(<span class="keyword">lambda</span> x:x[i]), reverse=<span class="literal">False</span>)	<span class="comment"># i表示对第几个维度进行排序, reverse默认False升序, 有返回值, 返回排序好的列表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">takeSecond</span>(<span class="params">elem</span>):	<span class="comment"># 获取列表的第二个元素</span></span><br><span class="line">    <span class="keyword">return</span> elem[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">list</span>.sort(key=takeSecond)	<span class="comment"># 与上面效果一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list -&gt; str</span></span><br><span class="line">list3 = [<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;google&#x27;</span>, <span class="string">&#x27;com&#x27;</span>]</span><br><span class="line">str4 = <span class="string">&quot;&quot;</span>.join(list3)	<span class="comment"># wwwgooglecom</span></span><br><span class="line">str5 = <span class="string">&quot;.&quot;</span>.join(list3)	<span class="comment"># www.google.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组的最大值</span></span><br><span class="line">arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">max_val = <span class="built_in">max</span>(<span class="built_in">max</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> arr)</span><br><span class="line"><span class="built_in">print</span>(max_val)  <span class="comment"># 输出 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指针问题，copy()问题</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = []</span><br><span class="line">c = []</span><br><span class="line">b.append(a)	<span class="comment"># b = [[1, 2, 3]]</span></span><br><span class="line">c.append(a.copy())	<span class="comment"># c = [[1, 2, 3]]</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment"># b = [[1, 2, 5]], 因为b加入是a的指针，所以a修改相应b里也会修改</span></span><br><span class="line"><span class="built_in">print</span>(c)	<span class="comment"># b = [[1, 2, 3]], 因为copy()是在内存中开辟新内存来存a的内容，所以a再修改是不影响c里的内容的</span></span><br><span class="line">					<span class="comment"># 如果append是int类型，则无需copy()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组转成一维数组</span></span><br><span class="line">mulArrays = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(mulArrays,[])) <span class="comment">#[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h2>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加操作，如果元素已存在，则不进行任何操作。</span></span><br><span class="line">s.add(<span class="string">&quot;Facebook&quot;</span>)	<span class="comment"># &#123;&#x27;Taobao&#x27;, &#x27;Facebook&#x27;, &#x27;Google&#x27;, &#x27;Runoob&#x27;&#125;</span></span><br><span class="line">s.update(&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)	<span class="comment"># &#123;1, 3, &#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除元素</span></span><br><span class="line">s.remove(<span class="string">&quot;Taobao&quot;</span>)	<span class="comment"># &#123;&#x27;Google&#x27;, &#x27;Runoob&#x27;&#125;</span></span><br><span class="line">s.remove(<span class="string">&quot;Facebook&quot;</span>)	<span class="comment"># 不存在会发生错误</span></span><br><span class="line">s.discard(<span class="string">&quot;Facebook&quot;</span>)	<span class="comment"># 不存在不会发生错误</span></span><br></pre></td></tr></table></figure>



<h2 id="dict（字典-哈希表）"><a href="#dict（字典-哈希表）" class="headerlink" title="dict（字典/哈希表）"></a>dict（字典/哈希表）</h2>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典取值</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;nanjing&#x27;</span>, <span class="string">&#x27;university&#x27;</span>: <span class="string">&#x27;NUAA&#x27;</span>, <span class="string">&#x27;college&#x27;</span>: <span class="string">&#x27;cs&#x27;</span>, <span class="string">&#x27;degree&#x27;</span>: <span class="string">&#x27;master&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 返回指定键的值</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">dict</span>.get(<span class="string">&quot;city&quot;</span>) == <span class="string">&quot;nanjing&quot;</span></span><br><span class="line"><span class="comment"># 返回指定键的值，如果值在字典中，default值无效</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">dict</span>.get(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;Shanghai&quot;</span>) == <span class="string">&quot;nanjing&quot;</span></span><br><span class="line"><span class="comment"># 返回指定键的值，如果值不在字典中，返回default值</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">dict</span>.get(<span class="string">&quot;province&quot;</span>, <span class="string">&quot;jiangshu&quot;</span>) == <span class="string">&quot;jiangshu&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dict赋值</span></span><br><span class="line">m = &#123;&#125;</span><br><span class="line">m[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span>	<span class="comment"># map中有a:1, b:2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典修改</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;nanjing&#x27;</span>, <span class="string">&#x27;university&#x27;</span>: <span class="string">&#x27;NUAA&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 和get()类似</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>.setdefault(<span class="string">&#x27;city&#x27;</span>))	<span class="comment"># nanjing</span></span><br><span class="line"><span class="comment"># 但如果键不存在于字典中，将会返回default值。 并且修改字典，添加键并将值设为default</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>.setdefault(<span class="string">&#x27;college&#x27;</span>, <span class="string">&#x27;cs&#x27;</span>))    <span class="comment"># cs</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>.setdefault(<span class="string">&#x27;location&#x27;</span>))    <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>)    <span class="comment">#  &#123;&#x27;city&#x27;: &#x27;nanjing&#x27;, &#x27;university&#x27;: &#x27;NUAA&#x27;, &#x27;college&#x27;: &#x27;cs&#x27;, &#x27;location&#x27;: None&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测键 city 是否存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;city&#x27;</span> <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;键 city 存在&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;键 city 不存在&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典遍历</span></span><br><span class="line">m = &#123;a:<span class="number">1</span>, b:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> m.items():	<span class="comment"># &#123;a:1, b:2&#125;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> m.keys():	<span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> m.values():	<span class="comment"># [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典合并</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&quot;city&quot;</span>:<span class="string">&quot;nanjing&quot;</span>, <span class="string">&quot;university&quot;</span>:<span class="string">&quot;NUAA&quot;</span>&#125;</span><br><span class="line">dict_2 = &#123;<span class="string">&quot;college&quot;</span>:<span class="string">&quot;cs&quot;</span>, <span class="string">&quot;degree&quot;</span>:<span class="string">&quot;master&quot;</span>&#125;</span><br><span class="line"><span class="built_in">dict</span>.update(dict_2)	<span class="comment"># &#123;&#x27;city&#x27;: &#x27;nanjing&#x27;, &#x27;university&#x27;: &#x27;NUAA&#x27;, &#x27;college&#x27;: &#x27;cs&#x27;, &#x27;degree&#x27;: &#x27;master&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">a_dict = &#123;<span class="string">&#x27;100&#x27;</span>: &#123;<span class="string">&#x27;1&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">                  <span class="string">&#x27;2&#x27;</span>: <span class="literal">None</span>&#125;,</span><br><span class="line">          <span class="string">&#x27;200&#x27;</span>: &#123;<span class="string">&#x27;3&#x27;</span>: <span class="literal">None</span>&#125;&#125;</span><br><span class="line">b_dict = &#123;<span class="string">&#x27;100&#x27;</span>: &#123;<span class="string">&#x27;1&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">                  <span class="string">&#x27;5&#x27;</span>: <span class="literal">None</span>&#125;,</span><br><span class="line">          <span class="string">&#x27;300&#x27;</span>: &#123;<span class="string">&#x27;4&#x27;</span>: <span class="literal">None</span>&#125;&#125;</span><br><span class="line">a_dict.update(b_dict)	<span class="comment"># 如果合并时，存在相同的 key 值，那么只会保留后者的键值对，而非合并。&#123;&#x27;100&#x27;: &#123;&#x27;1&#x27;: None, &#x27;5&#x27;: None&#125;, &#x27;200&#x27;: &#123;&#x27;3&#x27;: None&#125;, &#x27;300&#x27;: &#123;&#x27;4&#x27;: None&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典删除</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;nanjing&#x27;</span>, <span class="string">&#x27;university&#x27;</span>: <span class="string">&#x27;NUAA&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># pop()，删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>.pop(<span class="string">&#x27;city&#x27;</span>))    <span class="comment"># nanjing</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>)    <span class="comment"># &#123;&#x27;university&#x27;: &#x27;NUAA&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>.pop(<span class="string">&#x27;city&#x27;</span>, <span class="string">&#x27;college&#x27;</span>))    <span class="comment"># city不在dict中，所以返回默认值college</span></span><br><span class="line"><span class="comment"># del()，删除key-value</span></span><br><span class="line">dict_1 = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;nanjing&#x27;</span>, <span class="string">&#x27;university&#x27;</span>: <span class="string">&#x27;NUAA&#x27;</span>, <span class="string">&#x27;college&#x27;</span>: <span class="string">&#x27;cs&#x27;</span>, <span class="string">&#x27;degree&#x27;</span>: <span class="string">&#x27;master&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dict_1[<span class="string">&#x27;city&#x27;</span>]	<span class="comment"># &#123;&#x27;university&#x27;: &#x27;NUAA&#x27;, &#x27;college&#x27;: &#x27;cs&#x27;, &#x27;degree&#x27;: &#x27;master&#x27;&#125;</span></span><br><span class="line"><span class="comment"># popitem()，随机返回并删除字典中的一对键和值(一般删除末尾对)。</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;nanjing&#x27;</span>, <span class="string">&#x27;university&#x27;</span>: <span class="string">&#x27;NUAA&#x27;</span>, <span class="string">&#x27;college&#x27;</span>: <span class="string">&#x27;cs&#x27;</span>, <span class="string">&#x27;degree&#x27;</span>: <span class="string">&#x27;master&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>.popitem())    <span class="comment"># (&#x27;degree&#x27;, &#x27;master&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>)    <span class="comment"># &#123;&#x27;city&#x27;: &#x27;nanjing&#x27;, &#x27;university&#x27;: &#x27;NUAA&#x27;, &#x27;college&#x27;: &#x27;cs&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典清空</span></span><br><span class="line">dict_1 = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;nanjing&#x27;</span>, <span class="string">&#x27;university&#x27;</span>: <span class="string">&#x27;NUAA&#x27;</span>, <span class="string">&#x27;college&#x27;</span>: <span class="string">&#x27;cs&#x27;</span>, <span class="string">&#x27;degree&#x27;</span>: <span class="string">&#x27;master&#x27;</span>&#125;</span><br><span class="line">dict_1.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># collections.Counter()</span></span><br><span class="line"><span class="comment"># elements() 按照counter的计数，重复返回元素</span></span><br><span class="line">c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>, c=<span class="number">0</span>, d=-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">list</span>(c.elements())	<span class="comment"># [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># most_common(n) 按照counter的计数，按照降序，返回前n项组成的list; n忽略时返回全部</span></span><br><span class="line">Counter(<span class="string">&#x27;abracadabra&#x27;</span>).most_common(<span class="number">3</span>)	<span class="comment">#[(&#x27;a&#x27;, 5), (&#x27;r&#x27;, 2), (&#x27;b&#x27;, 2)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># subtract([iterable-or-mapping]) counter按照相应的元素，计数相减</span></span><br><span class="line">c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>, c=<span class="number">0</span>, d=-<span class="number">2</span>)</span><br><span class="line">d = Counter(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">c.subtract(d)	<span class="comment"># Counter(&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 0, &#x27;c&#x27;: -3, &#x27;d&#x27;: -6&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># update([iterable-or-mapping]) 不同于字典的update方法，这里更新counter时，相同的key的value值相加而不是覆盖</span></span><br><span class="line"><span class="comment"># 实例化 Counter 时，实际也是调用这个方法</span></span><br><span class="line">c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>, c=<span class="number">0</span>, d=-<span class="number">2</span>)</span><br><span class="line">d = Counter(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">c.update(d)	<span class="comment"># Counter(&#123;&#x27;a&#x27;: 5, &#x27;b&#x27;: 4, &#x27;c&#x27;: 3, &#x27;d&#x27;: 2&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Counter 间的数学集合操作</span></span><br><span class="line">c = Counter(a=<span class="number">3</span>, b=<span class="number">1</span>, c=<span class="number">5</span>)</span><br><span class="line">d = Counter(a=<span class="number">1</span>, b=<span class="number">2</span>, d=<span class="number">4</span>)</span><br><span class="line">c + d	<span class="comment"># counter相加，相同的key的value相加，Counter(&#123;&#x27;c&#x27;: 5, &#x27;a&#x27;: 4, &#x27;d&#x27;: 4, &#x27;b&#x27;: 3&#125;)</span></span><br><span class="line">c - d	<span class="comment"># counter相减，相同的key的value相减，只保留正值得value，Counter(&#123;&#x27;c&#x27;: 5, &#x27;a&#x27;: 2&#125;)</span></span><br><span class="line">c &amp; d	<span class="comment"># 交集:  取两者都有的key,value取小的那一个，Counter(&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 1&#125;)</span></span><br><span class="line">c | d	<span class="comment"># 并集:  汇聚所有的key, key相同的情况下，取大的value，Counter(&#123;&#x27;c&#x27;: 5, &#x27;d&#x27;: 4, &#x27;a&#x27;: 3, &#x27;b&#x27;: 2&#125;)</span></span><br><span class="line">常见做法:</span><br><span class="line"><span class="built_in">sum</span>(c.values())                 <span class="comment"># 继承自字典的.values()方法返回values的列表，再求和</span></span><br><span class="line">c.clear()                       <span class="comment"># 继承自字典的.clear()方法，清空counter</span></span><br><span class="line"><span class="built_in">list</span>(c)                         <span class="comment"># 返回key组成的list</span></span><br><span class="line"><span class="built_in">set</span>(c)                          <span class="comment"># 返回key组成的set</span></span><br><span class="line"><span class="built_in">dict</span>(c)                         <span class="comment"># 转化成字典</span></span><br><span class="line">c.items()                       <span class="comment"># 转化成(元素，计数值)组成的列表</span></span><br><span class="line">Counter(<span class="built_in">dict</span>(list_of_pairs))    <span class="comment"># 从(元素，计数值)组成的列表转化成Counter</span></span><br><span class="line">c.most_common()[:-n-<span class="number">1</span>:-<span class="number">1</span>]       <span class="comment"># 最小n个计数的(元素，计数值)组成的列表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="heapq（堆-优先队列）"><a href="#heapq（堆-优先队列）" class="headerlink" title="heapq（堆/优先队列）"></a>heapq（堆/优先队列）</h2>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建堆（默认为小顶堆）</span></span><br><span class="line">heap = []	<span class="keyword">or</span> heapq.heapify(x)	<span class="comment"># 将 list x 转换成堆，原地，线性时间内，无返回值。</span></span><br><span class="line">heapq.heapify(-x)	<span class="comment"># 大顶堆，输出的时候记得补上负号还原值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 item 的值加入 heap 中，保持堆的不变性。</span></span><br><span class="line">heapq.heappush(heap, item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出并返回 heap 的最小的元素，保持堆的不变性。如果堆为空，抛出 IndexError 。使用 heap[0] ，可以只访问最小的元素而不弹出它。</span></span><br><span class="line">heapq.heappop(heap)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 item 放入堆中，然后弹出并返回 heap 的最小元素。</span></span><br><span class="line">heapq.heappushpop(heap, item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出和返回堆中的最小值再插入一个新的值。堆的大小没有改变。如果堆为空，产生 IndexError。</span></span><br><span class="line">heapq.heapreplace(heap, item)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="queue（队列）"><a href="#queue（队列）" class="headerlink" title="queue（队列）"></a>queue（队列）</h2>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 两端队列</span></span><br><span class="line">deque = queue.deque([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>])</span><br><span class="line"><span class="comment"># 入队一个</span></span><br><span class="line">deque.appendleft(<span class="string">&#x27;0&#x27;</span>)	<span class="comment"># [&#x27;0&#x27;, 1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br><span class="line">deque.append(<span class="string">&#x27;6&#x27;</span>)	<span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 入队一组</span></span><br><span class="line">deque.extendleft([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])	<span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, 1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br><span class="line">deque.extend([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])	<span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 出队</span></span><br><span class="line">deque.popleft()	<span class="comment"># &#x27;1&#x27;</span></span><br><span class="line">deque.pop()	<span class="comment"># &#x27;5&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line">deque.insert(<span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>)	<span class="comment"># [&#x27;0&#x27;, 1&#x27;, &#x27;2&#x27;, &#x27;a&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列</span></span><br><span class="line">queue = queue.Queue(<span class="number">5</span>) <span class="keyword">or</span> queue = queue.Queue([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>])	<span class="comment"># 5表示长度，默认无限长</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 入队</span></span><br><span class="line">queue.put(<span class="number">1</span>)	<span class="comment"># [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 出队</span></span><br><span class="line">queue.get()	<span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回队列的大小</span></span><br><span class="line">queue.qsize()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果队列为空，返回True,反之False</span></span><br><span class="line">queue.empty()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果队列满了，返回True,反之False</span></span><br><span class="line">queue.full()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取队列</span></span><br><span class="line">queue.get([block[, timeout]]) <span class="comment"># timeout等待时间</span></span><br><span class="line">queue.get_nowait() <span class="comment"># 相当Queue.get(False)</span></span><br></pre></td></tr></table></figure>



<h2 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h2>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># map()会根据提供的函数对指定序列做映射，返回为迭代器。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>) :</span><br><span class="line">		<span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))   <span class="comment"># 输出[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2475. 数组中不等三元组的数目</title>
    <url>/2023/05/10/Leetcode-2475/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个下标从 0 开始的正整数数组 nums，请你找出并统计满足下述条件的三元组 (i, j, k) 的数目：</p>
<ul>
<li>0 &lt;= i &lt; j &lt; k &lt; nums.length</li>
<li>nums[i]、nums[j] 和 nums[k] 两两不同 。<br>换句话说：nums[i] != nums[j]、nums[i] != nums[k] 且 nums[j] != nums[k] 。</li>
</ul>
<p>返回满足上述条件三元组的数目。</p>
<p>示例1:</p>
<p><strong>输入</strong>：nums = [4,4,2,4,3]</p>
<p><strong>输出</strong>：3</p>
<p><strong>解释</strong>：下面列出的三元组均满足题目条件：</p>
<ul>
<li>(0, 2, 4) 因为 4 != 2 != 3</li>
<li>(1, 2, 4) 因为 4 != 2 != 3</li>
<li>(2, 3, 4) 因为 2 != 4 != 3</li>
</ul>
<p>共计 3 个三元组，返回 3 。</p>
<p>注意 (2, 0, 4) 不是有效的三元组，因为 2 &gt; 0 。</p>
<p>示例2:</p>
<p><strong>输入</strong>：nums = [1,1,1,1,1]</p>
<p><strong>输出</strong>：0</p>
<p><strong>解释</strong>：不存在满足条件的三元组，所以返回 0 。</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可用排序+共享来解题</p>
<p>依次遍历不同的数字x，找到比x小的数的个数a，比x大的个数b，则对于x来说一共有x$\times$a$\times$b个符合条件的组合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unequalTriplets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        start, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(pairwise(nums)): <span class="comment"># 打包可以之间得到i的下一个数</span></span><br><span class="line">            <span class="keyword">if</span> x != y:</span><br><span class="line">                ans += start * (i - start + <span class="number">1</span>) * (<span class="built_in">len</span>(nums) - <span class="number">1</span> - i)    <span class="comment"># 注意边界条件</span></span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>今日头条一面</title>
    <url>/2023/05/11/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="今日头条一面"><a href="#今日头条一面" class="headerlink" title="今日头条一面"></a>今日头条一面</h1><ol>
<li>自我介绍（主要介绍简历上的内容，研究生和本科的经历。工作室，开发经验啥的）</li>
<li>问了简历上的一些科研，最有收获的项目，研究生所做的课题。</li>
<li>数据库相关知识（mysql，radit，因为我不太熟就没有多问）</li>
<li>操作系统问题<ul>
<li>说说线程和进程的区别（进程是资源分配的最小单位，线程可以共享进程的资源），最后问了个协程</li>
<li>谈谈内核态和用户态（就答了个中断，没答出来）</li>
</ul>
</li>
<li>计算机网络问题<ul>
<li>输入一个网址到返回内容至浏览器都经历了什么（DNS，三次握手，四次挥手）</li>
<li>简述HTTP和HTTPs</li>
<li>TCP和UDP的区别</li>
<li>说出利用TCP连接的应用层协议（SMTP，HTTP，Telnet，FTP），利用UDP的应用层协议（DNS，实时通讯，实况转播）</li>
</ul>
</li>
<li>数据结构问题<ul>
<li>B树和B+树的区别</li>
<li>B树、B+树和红黑树的区别（红黑树没了解就没答出来）</li>
</ul>
</li>
<li>代码题<ul>
<li>最长不重复子串的长度（滑动窗口+hashmap）</li>
<li>判断链表是否为循环链表（时间不够未完成）</li>
</ul>
</li>
<li>问面试官问题<ul>
<li>做开发需要什么（需要了解一门语言，需要有自己的技术栈，数据库，网络编程等等）</li>
</ul>
</li>
</ol>
<h1 id="后续发展"><a href="#后续发展" class="headerlink" title="后续发展"></a>后续发展</h1><ol>
<li>去复习一下计算机网络和操作系统有关知识</li>
<li>刷题还要继续，要提升写代码的速度</li>
<li>对数据结构还需要再了解一下</li>
<li><strong>要去了解学习数据库已经计算机网络编程的一些技术栈</strong></li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>1110. 删点成林</title>
    <url>/2023/05/30/Leetcode-1110/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出二叉树的根节点 root，树上每个节点都有一个不同的值。</p>
<p>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。</p>
<p>返回森林中的每棵树。你可以按任意顺序组织答案。</p>
<p><strong>示例1</strong>:</p>
<p><strong>输入</strong>：root = [1,2,3,4,5,6,7], to_delete = [3,5]</p>
<p><strong>输出</strong>：[[1,2,null,4],[6],[7]]</p>
<p><img src="https://github.com/wuli-tao/wuli-tao.github.io/blob/master/image/1110.png?raw=true" alt="image"></p>
<p><strong>示例2</strong>:</p>
<p><strong>输入</strong>：root = [1,2,4,null,3], to_delete = [3]</p>
<p><strong>输出</strong>：[[1,2,4]]</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>利用深度优先遍历每一个节点。<font color="#dd0000">isRoot标志着该节点是否是一个新的树。</font>函数中，首先判断这个节点是否要被删除，如果是，那么它的两个子节点（如果有的话）便成为了潜在的根节点。如果这个节点的值不在 to_delete 中并且 isRoot 为 true，那么这个节点便成为了一个新的根节点，需要把它放入结果数组中。同时也要对它的两个子节点进行同样的操作。<font color="#dd0000">dfs返回值是更新后的node。</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], to_delete: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[TreeNode]:</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(root, <span class="literal">True</span>, to_delete, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, node, isRoot, to_delete, ans</span>):</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        isDelete = node.val <span class="keyword">in</span> to_delete</span><br><span class="line"></span><br><span class="line">        node.left = self.dfs(node.left, isDelete, to_delete, ans)   <span class="comment"># 该处要有返回值，要更新该节点的左右孩子，若删除返回None，则不会加入到ans中</span></span><br><span class="line">        node.right = self.dfs(node.right, isDelete, to_delete, ans)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isDelete:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> isRoot:</span><br><span class="line">                ans.append(node)</span><br><span class="line">            <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>2517. 礼盒的最大甜蜜度</title>
    <url>/2023/06/01/Leetcode-2517/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数数组 price ，其中 price[i] 表示第 i 类糖果的价格，另给你一个正整数 k 。</p>
<p>商店组合 k 类 不同 糖果打包成礼盒出售。礼盒的 甜蜜度 是礼盒中任意两种糖果 价格 绝对差的最小值。</p>
<p>返回礼盒的 最大 甜蜜度。</p>
<p><strong>示例1</strong>:</p>
<p><strong>输入</strong>：price = [13,5,1,8,21,2], k = 3</p>
<p><strong>输出</strong>：8</p>
<p><strong>解释</strong>：选出价格分别为 [13,5,21] 的三类糖果。</p>
<p>礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8 。</p>
<p>可以证明能够取得的最大甜蜜度就是 8 。</p>
<p><strong>示例2</strong>:</p>
<p><strong>输入</strong>：price = [1,3,1], k = 2</p>
<p><strong>输出</strong>：2</p>
<p><strong>解释</strong>：选出价格分别为 [1,3] 的两类糖果。</p>
<p>礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。</p>
<p>可以证明能够取得的最大甜蜜度就是 2 。</p>
<p><strong>示例3</strong>:</p>
<p><strong>输入</strong>：price = [7,7,7,7], k = 2</p>
<p><strong>输出</strong>：0</p>
<p><strong>解释</strong>：从现有的糖果中任选两类糖果，甜蜜度都会是 0 。</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>「任意两种糖果价格绝对差的最小值」等价于「排序后，任意两种相邻糖果价格绝对差的最小值」。</p>
<p><font color="#dd0000">如果题目中有「最大化最小值」或者「最小化最大值」，一般都是二分答案。</font></p>
<p>为什么？对于本题来说，甜蜜度越大，能选择的糖果越少，有单调性，所以可以二分。</p>
<p>定义 f(d) 表示甜蜜度至少为 d 时，至多能选多少类糖果。</p>
<p>二分答案 d：</p>
<ul>
<li>如果 f(d)≥kf(d)，说明答案至少为 d。</li>
<li>如果 f(d)&lt;kf(d)，说明答案至多为 d−1。</li>
<li>二分结束后，设答案为 $d_0$，那么 f(d0)≥k 且 f(d0+1)&lt;k。</li>
</ul>
<p>如何计算 f(d)？对 price 从小到大排序，贪心地计算 f(d)：从 price[0] 开始选；假设上一个选的数是 x，那么当 price[i]≥x + d 时，才可以选 price[i]。</p>
<p>二分下界可以取 1，上界可以取 ⌊$\frac{max⁡(price)−min⁡(price)}{k−1}$⌋，这是因为最小值不会超过平均值。（平均值指选了 price 最小最大以及中间的一些糖果，相邻糖果差值的平均值。）</p>
<p>请注意，二分的区间的定义是：尚未确定 f(d) 与 k 的大小关系的 d 的值组成的集合（范围）。在区间左侧外面的 d 都是 f(d)≥k 的，在区间右侧外面的 d 都是 f(d) 的。在理解二分时，请牢记区间的定义及其性质。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumTastiness</span>(<span class="params">self, price: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        price.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mid</span>):</span><br><span class="line">            x, cnt = price[<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> price:</span><br><span class="line">                <span class="keyword">if</span> p - x &gt;= mid:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    x = p</span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= k</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, (price[-<span class="number">1</span>] - price[<span class="number">0</span>]) // (k - <span class="number">1</span>) + <span class="number">1</span>  <span class="comment"># 此处是开区间</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                left = mid  <span class="comment"># 开区间直接赋值mid</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid <span class="comment"># 开区间直接赋值mid</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2023/06/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="算法理论"><a href="#算法理论" class="headerlink" title="算法理论"></a>算法理论</h2><ul>
<li><p>[0, …, n]左闭右闭</p>
</li>
<li><p>[0, …, n)左闭右开</p>
</li>
<li><p>(0, …, n]左开右闭</p>
</li>
<li><p>(0, …, n)左开右开</p>
</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>要注意集合的开闭问题while left &lt; right or while left &lt;= right，要注意返回值left or left+1。（根据具体题目来判断）</p>
]]></content>
  </entry>
  <entry>
    <title>1156. 单字符重复子串的最大长度</title>
    <url>/2023/06/03/Leetcode-1156/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。</p>
<p>给你一个字符串 text，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。</p>
<p><strong>示例1</strong>:</p>
<p><strong>输入</strong>：text = “ababa”</p>
<p><strong>输出</strong>：3</p>
<p><strong>示例2</strong>:</p>
<p><strong>输入</strong>：text = “aaabaaa”</p>
<p><strong>输出</strong>：6</p>
<p><strong>示例3</strong>:</p>
<p><strong>输入</strong>：text = “aaabbaaa”</p>
<p><strong>输出</strong>：4</p>
<p><strong>示例4</strong>:</p>
<p><strong>输入</strong>：text = “aaaaa”</p>
<p><strong>输出</strong>：5</p>
<p><strong>示例5</strong>:</p>
<p><strong>输入</strong>：text = “abcdef”</p>
<p><strong>输出</strong>：1</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们设 n 为字符串 text 的长度，下标从 0 开始，现在有一段区间 [i,j) （不包括 j ）由相同字符 a 构成，并且该区间两边不存在相同的字符 a，而整个 text 中 a 的出现次数为 count[a]，那么当 count[a]&gt;j−i ，并且 i&gt;0 或者 j&lt;n 时，可以将其他地方出现的 a 与 text[i−1] 或 text[j] 交换，从而得到更长的一段仅包含字符 a 的子串。</p>
<p>交换后，交换过来的 aaa 可能会使得两段连续的 a 拼接在一起，我们假设 [i,j) 是前面的一段，当 text[j+1]=a 时，我们在找到后面的一段 [j+1,k)，这两段拼接在一起构成更长的子串。注意，我们需要重新判断是否有多余的 a 交换到中间来，因此将拼接后的长度 k−i 与 count[a] 取最小值来更新答案。</p>
<ul>
<li><p>如何确定以哪个字符开始计算？</p>
<p>从第一个字符开始遍历即可</p>
</li>
<li><p>如何确定划分的中点</p>
<p>滑动窗口的形式，三个指针，[left, mid)，[mid + 1, right)为两段，mid 指向第一个和text[left]不同的字符所在位置</p>
</li>
<li><p>若是abbaaaaa这样的形式，怎么做到 6 个 a 连在一起</p>
<p>在第一个a的时候显然是做不到 6 个 a 连在一起，但是在后面5个a的时候，left &gt; 0 并且 5 个 a 是小于 a 的总长度 6 的，所以在第二步时会 +1，相当于在 5 个 a 之前加入一个 a，最后结果是 6</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxRepOpt1</span>(<span class="params">self, text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = collections.Counter(text)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> left <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(text)):</span><br><span class="line">            <span class="comment"># 找出第一段以text[i]开头连续的一段</span></span><br><span class="line">            mid = left</span><br><span class="line">            <span class="keyword">while</span> mid &lt; <span class="built_in">len</span>(text) <span class="keyword">and</span> text[mid] == text[left]:</span><br><span class="line">                mid += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 若该段前或后有非相同字符，并且该段出现的字符数小于总字符数，则在当前基础cur_ans上可以+1</span></span><br><span class="line">            cur_ans = mid - left</span><br><span class="line">            <span class="keyword">if</span> cur_ans &lt; count[text[left]] <span class="keyword">and</span> (left &gt; <span class="number">0</span> <span class="keyword">or</span> mid &lt; <span class="built_in">len</span>(text)):</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cur_ans + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 找到与第一段隔一个字符的第二段</span></span><br><span class="line">            right = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(text) <span class="keyword">and</span> text[right] == text[left]:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(right - left, count[text[left]]))</span><br><span class="line">            left = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-820</title>
    <url>/2023/06/03/Leetcode-820/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：</p>
<ul>
<li>words.length == indices.length</li>
<li>助记字符串 s 以 ‘#’ 字符结尾</li>
<li>对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 ‘#’ 字符结束（但不包括 ‘#’）的 子字符串 恰好与 words[i] 相等</li>
</ul>
<p>给你一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。</p>
<p><strong>示例1</strong>:</p>
<p><strong>输入</strong>：words = [“time”, “me”, “bell”]</p>
<p><strong>输出</strong>：10</p>
<p><strong>解释</strong>：一组有效编码为 s = “time#bell#” 和 indices = [0, 2, 5] 。</p>
<p>words[0] = “time” ，s 开始于 indices[0] = 0 到下一个 ‘#’ 结束的子字符串，如加粗部分所示 “time#bell#”</p>
<p>words[1] = “me” ，s 开始于 indices[1] = 2 到下一个 ‘#’ 结束的子字符串，如加粗部分所示 “time#bell#”</p>
<p>words[2] = “bell” ，s 开始于 indices[2] = 5 到下一个 ‘#’ 结束的子字符串，如加粗部分所示 “time#bell#”</p>
<p><strong>示例2</strong>:</p>
<p><strong>输入</strong>：words = [“t”]</p>
<p><strong>输出</strong>：2</p>
<p><strong>解释</strong>：一组有效编码为 s = “t#” 和 indices = [0] 。</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果单词 X 是 Y 的后缀，那么单词 X 就不需要考虑了，因为编码 Y 的时候就同时将 X 编码了。例如，如果 words 中同时有 “me” 和 “time”，我们就可以在不改变答案的情况下不考虑 “me”。</p>
<p>如果单词 Y 不在任何别的单词 X 的后缀中出现，那么 Y 一定是编码字符串的一部分。</p>
<p>因此，目标就是保留所有不是其他单词后缀的单词，最后的结果就是这些单词长度加一的总和，因为每个单词编码后后面还需要跟一个 # 符号。</p>
<ul>
<li><p>怎么判断该word包不包含在其他word中</p>
<p>后缀表示，可以将words加入到set中，若该word是其余word的后缀，则在set中删除该word</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumLengthEncoding</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="built_in">set</span>(words)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(word)):</span><br><span class="line">                s.discard(word[i:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> s:</span><br><span class="line">            ans += <span class="built_in">len</span>(word) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>后缀</tag>
      </tags>
  </entry>
</search>
